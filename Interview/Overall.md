# Important Aspects

- Communication: **asking for requirements and clarity** when necessary; Initial tech screen should be a conversation, don't forget to ask questions.

- Problem solving: how you **comprehend and expain complex ideas**; provide **the reasoning** behind a particular solution; **developing and comparing multiple solutions**; using **appropriate data structures**; speaking about the **space and time complexity**; **optimizing your solution**

- Coding: convert solutions to executable code? Is the **code organized** and does it **capture the right logical structure**

- Verification: **Considering a reasonable number of test cases**; it there's bug, **find the with your own logic and explain what is doing**.  

---
# How to prepare

## Plan: 

- schedule time to study and practice
- target medium and hard problems
- Prioritize breadth over depth
- Set aside time to review what you've practiced
- Remember your goal.

## Use key practice strategies to pracitce effectively:

- practice coding the way you'll code during your tech screen

- **set a time constraint when you practice problems**

- code in your strongest language

- **practice talking through the problem space and possible solutions before you dive in, and talk through your decisions out loud as you code**


## Understand the types of problems you may encounter

- Problems may access the depth of your knowledge and your versatility. 

- Problems may focus on edge cases

- Problems may test how well you know things work under the hood

---
# How to Approach Problems During Your Interview

## Before you code

- ask clarifying questions

- let us know if you've seen the problem previously

- present multiple potential solutions, if possible

## While you code

- don't forget to talk

- be flexible (if you get stuck, describe your best approach and ask the interviewer if you should go that route)

- iterate rather than immediately trying to jump to the clever solution

- generally, avoid solutions with lots of edge cases or huge if/else if/else blocks

*Consider*
- different algorithms and algorithmic techniques, such as sorting, divide-and-conquer, recursion
- data structures, (array, stack/queue, hashset/hashmap/hashtable/dictionary, tree/binary tree, heap, graph)
- O memory constraints on the complexity of the algorithm you're writing and its running time as expressed by big-O notation

## After you code

- expect questions

- take the interviewer's hints to improve your code

- as yourself if you would approve your solution as part of your codebase


---
# Resources

- [Big O Notation](https://www.youtube.com/watch?v=v4cd1O4zkGw)
- [Lists](https://www.youtube.com/watch?v=wjI1WNcIntg)
- [Stacks & Queues](https://www.hackerrank.com/challenges/waiter/problem)
- [Hash & Maps](https://www.youtube.com/watch?v=shs0KM3wKv8) (**Watched**)
- [Sorting Algorithms](https://www.youtube.com/watch?v=KF2j-9iSf4Q)
- [Trees](https://www.youtube.com/watch?v=oSWTXtMglKE&t=138s)
- [Graphs(BFS & DFS)](https://www.youtube.com/watch?v=zaBhtODEL0w)
- [Recursion](https://www.youtube.com/watch?v=KEEKn7Me-ms)

---
# Exercise

- [InterviewBit](https://www.interviewbit.com/search/?q%5B%5D=Facebook)
