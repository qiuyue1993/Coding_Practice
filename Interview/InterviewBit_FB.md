# InterviewBit of FB

## Indexing:
- [Arrays](#Arrays)
- [Math](#Math)
- [Binary Search](#Binary-Search)
- [Strings](#Strings)
- [Two Pointers](#Two-Pointers)
- [Linked Lists](#Linked-Lists)
- [Stacks And Queues](#Stacks-And-Queues)
- [Backtracking](#Backtracking)
- [Hashing](#Hashing)
- [Tree Data Structure](#Tree-Data-Structure)
- [Dynamic Programming](#Dynamic-Programming)
- [Graph Data Structure & Algorithms](#Graph-Data-Structure-&-Algorithms)
---
## Arrays
### Exercises
*Rotate Matrix*
- It is important to learn to observe

*Max Sum Contiguous Subarray*
- Kind of tricky

---
## Math
### Exercises
*Rearrange Array*
- Tricky
- **Save two number in one number (%, +)**

---
## Binary Search
### Exercises
*Square Root of Integer*
- Totally, looping is better than recursion

---
## Strings
*Implement StrStr*
- Do things carefully

*Integer To Roman*
- The rule is the key:
- Ones place: I V
- Tens place: X L
- Hundreds place: C D
- Thousands place: M

*Roman To Integer*
- Be carefull

---
## Two Pointers
*Diffk*
- Think about the given condition
- Think carefully

*Intersection Of Sorted Arrays*
- Very basic and simple

---
## Linked Lists
*Add Two Numbers as Lists*
- Basic and simple
- Be carefull

---
## Stacks And Queues
*Evaluate Expression*
- A simple and basic question

---
## Backtracking
***All Unique Permutations***
- Feature: every choice is equal; next step depends on the last step;
- Method: create a check table; create a loop, every time execute a possible choice; create next recursion; recover the choice

*Combination Sum*
- Very similar with the last question
- In each recursion, create an ending situation; create current loop; in each loop; make current choice; go to next recursion; recover the choice;
- Should be very careful
- Do not forget anything that should be recover

---
## Hashing
*Substring Concatenation*
- Should be very very carefully

*2 Sum*
- dict_.get(key,"None")
- In python, hash table means dictionary
- be carefull

*Diffk II*
- dict_.get(key, None)
- In python, hash table means dictionary

---
## Tree Data Structure
*Least Common Ancestor*
- Be carefull
- DFS: backtracking, need to recover

*Valid Binary Search Tree*
- Be careful to read the requirement

---
## Dynamic Programming
***Longest Increasing Subsequence***
- A new type of structure
- Figure out a smallest case; resorve the case; bigger case is based on the smaller cases

*Unique Paths in a Grid*
- d

---
## Graph Data Structure & Algorithms
*Level Order*
- d

*Clone Graph*
- d

---
- [References](https://www.interviewbit.com/search/?q%5B%5D=Facebook)
---
