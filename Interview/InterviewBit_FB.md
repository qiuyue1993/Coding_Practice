# InterviewBit of FB

## Indexing:
- [Arrays](#Arrays)
- [Math](#Math)
- [Binary Search](#Binary-Search)
- [Strings](#Strings)
- [Two Pointers](#Two-Pointers)
- [Linked Lists](#Linked-Lists)
- [Stacks And Queues](#Stacks-And-Queues)
- [Backtracking](#Backtracking)
- [Hashing](#Hashing)
- [Tree Data Structure](#Tree-Data-Structure)
- [Dynamic Programming](#Dynamic-Programming)
- [Graph Data Structure & Algorithms](#Graph-Data-Structure-&-Algorithms)
---
## Arrays
### Exercises
*Rotate Matrix*
- It is important to learn to observe

*Max Sum Contiguous Subarray*
- Kind of tricky

### Review 1
- 2019.11.20

---
## Math
### Exercises
*Rearrange Array*
- Tricky
- **Save two number in one number (%, +)**

### Review 1
- 2019.11.20

---
## Binary Search
### Exercises
*Square Root of Integer*
- Totally, looping is better than recursion

### Review 1
- 2019.11.20

---
## Strings
*Implement StrStr*
- Do things carefully

*Integer To Roman*
- The rule is the key:
- Ones place: I V
- Tens place: X L
- Hundreds place: C D
- Thousands place: M

*Roman To Integer*
- Be carefull

*Pretty Json*
- Too many edges
- Be carefull

*Count And Say*
- Basic
- Be carefull

### Review 1
- 2019.11.20

---
## Two Pointers
*Diffk*
- Think about the given condition
- Think carefully

*Intersection Of Sorted Arrays*
- Very basic and simple

*Sort by Color*
- Insertion sort

*Container With Most Water*
- Tricky

### Review 1
- 2019.11.20

---
## Linked Lists
*Add Two Numbers as Lists*
- Basic and simple
- Be carefull

### Review 1
- 2019.11.20

---
## Stacks And Queues
*Evaluate Expression*
- A simple and basic question

### Review 1
- 2019.11.20

---
## Backtracking
***All Unique Permutations***
- Feature: every choice is equal; next step depends on the last step;
- Method: create a check table; create a loop, every time execute a possible choice; create next recursion; recover the choice

*Combination Sum*
- Very similar with the last question
- In each recursion, create an ending situation; create current loop; in each loop; make current choice; go to next recursion; recover the choice;
- Should be very careful
- Do not forget anything that should be recover

### Review 1
- 2019.11.20

---
## Hashing
*Substring Concatenation*
- Should be very very carefully

*2 Sum*
- dict_.get(key,"None")
- In python, hash table means dictionary
- be carefull

*Diffk II*
- dict_.get(key, None)
- In python, hash table means dictionary

### Review 1
- 2019.11.20

---
## Tree Data Structure
*Least Common Ancestor*
- Be carefull
- DFS: backtracking, need to recover

*Valid Binary Search Tree*
- Be careful to read the requirement

### Review 1
- 2019.11.20
---
## Dynamic Programming
***Longest Increasing Subsequence***
- A new type of structure
- Figure out a smallest case; resorve the case; bigger case is based on the smaller cases

***Unique Paths in a Grid***
- Matrix DP
- Figure out a state; figure out how state transform.

*Ways to Decode*
- Need to think carefully
- A lot of edge situations

### Review 1
- 2019.11.20

---
## Graph Data Structure & Algorithms
*Level Order*
- Use two queues
- A very basic question

*Clone Graph*
- Two list to prevent circle
- DFS

### Review 1
- 2019.11.20

---
- [References](https://www.interviewbit.com/search/?q%5B%5D=Facebook)
---
